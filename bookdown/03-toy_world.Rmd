# Making a Toy World 

## Generation of Population

Our toy world bases on population census data from the German Federal Statistical Office [2] (https://www.destatis.de/EN/Home/_node.html). This data entails continous population counts on a 100m * 100m grid. *For our project we reduce the population count to a third to mimic the process of receiving data from an MNO provider - therefore we assume that the population count resembles the number of mobile phones in this area.* For computational reasons, this version will only focus on a subset of the tiles located in the state of Bavaria, which is situated in the south-east of Germany. We chose this area because it comprises a high diversity of urban, suburban, and rural areas.

*Terminology used in this project:*
Due to various definitions out there, it is imperial to define the different terminologies used in this project before going further to reduce unnecessary confusion.
- When we talk about *tiles*, we mean any square on the regular 100 * 100 m2 grid.
- An *antenna* is a device facilitating between radio transmission and reception. Specifically in our case, an antenna transmits and receives cell phone signals. This is also known as a *cell*.
- A (radio) *tower* or commonly referred to as a *cell tower, cellular site, or cellular base station* is a tower equipped with antennas.

```{r, setup, message = FALSE}
# change accordingly
#knitr::opts_knit$set(root.dir = normalizePath("C:/Users/Marco/")) 
knitr::opts_chunk$set(fig.width = 9)
knitr::opts_knit$set(eval.after = "fig.cap")
```

```{r packages, message=FALSE}
library(tidyverse)
library(sf)
library(raster)
library(Matrix)
library(knitr)
library(kableExtra)
library(ggthemes)
library(cowplot)
library(transformr)
library(gganimate)
set.seed(762)

census.de.100m.tile <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/census.tile.final.rds") 
```

Throughout this project, we are going to analyze the area of South Bavaria. Consequently in Figure 1, the interested area in highlighted with a red rectangle. More specifically, this zone is identified by a longitude between 4400000 and 4500000 and a latitude between 2700000 and 2900000. Moreover, the coordinates are transformed and converted so that it is possible to use the same convention through the entire research. 

```{r focus area, fig.width = 7, fig.cap="We will only focus on a subset of the tiles located in the state of Bavaria because it comprises both urban, suburban, and rural areas" }
# Bounding box of focus area
bb.focus.dat <- data.frame(xmin = 4400000, xmax = 4500000,
                           ymin = 2700000, ymax = 2900000)
bb.focus.vec <- c(xmin = 4400000, xmax = 4500000,
                  ymin = 2700000, ymax = 2900000)
# Download data from : https://gadm.org/download_country_v3.html --> R(sf) level 1
germany.raw <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/gadm36_DEU_1_sf.rds") 
germany <- germany.raw %>%  
  st_transform(crs = 3035)
focus.area.plot <- germany %>%  
  ggplot() + 
  geom_sf() + 
  geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
                                      xmin = xmin, xmax = xmax,  
                                     color = "red"),  
            size = 1, fill = "transparent") + 
  ggtitle("") + 
  scale_color_identity(name = "", 
                       labels = c("Focus area"), 
                       guide = "legend") +
  labs(x = NULL, y = NULL,
       title = "")
 
plot_grid(focus.area.plot, 
          labels = "Fig.1: Focusing on a part of South Bavaria",
          hjust = -0.1, label_size = 13)
```


As mentioned above, this area is very heterogeneous in urban-rural intensity. Knowing the location of urban centers is very important for the corresponding radio cell network as there are differences in cell coverage between these different area kinds. We are aiming at developing a 3-category classification for each tile: Rural, Suburban and Urban. Based on the census data on the tile level we cannot locate urban centers just yet. Classifying tiles on such a low spatial resolution into one of these categories independent from each other (i.e. based on their population numbers) would not lead to the true location of urban centers; in fact, we need to take spatial dependence into consideration in order to identify urban centers. Therefore we apply a spatial clustering algorithm to account for the spatial dependence. We aimed at having 4 different categories: Uninhabited, Rural, Suburban and Urban. In order to run the clustering algorithm, the original census population is first divided into tiles above and below 15 people per tile. Tiles below 15 are either classified as Uninhabited or Rural, from the start (uninhabited corresponds to the tiles with 0 population). The clustering is then done on the tiles that are above 15 people per tile. Based on the results of the clustering, we define urban areas as clusters that have an agglomeration of more than 100 tiles. Suburban areas are defined as clusters that have more than 50 and less than or equal to 100 tiles. The remaining clusters are considered as Rural areas and therefore result in the same classification as the tiles from above, which had less than 15 people.
We started with the definition of the data necessary for the Empirical Complementary Cumulative Distribution Function (ECCDF). This function is going to be further explained in Figure 3. 

The plots below present our classification results:
```{r pop distribution 1, fig.cap= "Figure 2a shows the classification results from the clustering algorithm and the proportion of people in the area categories.While Figure 2b shows the distribution of the four different categories of tiles obtained throught spatial clustering."}

# Since there is a large percentage of zeros in the tiles, we added 1 to every tile to receive valid values for the log transformation
# ECCDF of population distribution 
census.de.100m.tile <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/census.de.100m.tile.rds")
ECCDF.pop.data <- census.de.100m.tile %>% 
  # sample_n(1000) %>%
  mutate(pop.plot = pop + 1) %>%  
  arrange(pop.plot) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>%  
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.pop = log10(pop.plot)) %>%  
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(pop.area.kind = case_when(pop == 0 ~ "Uninhabitated", 
                                   TRUE ~ pop.area.kind))

prop.class <- data.frame( 
  class = c("Rural","Suburban", "Uninhabitated","Urban"), 
  n = summary(as.factor(ECCDF.pop.data$pop.area.kind)), 
  prop = round(summary(as.factor(ECCDF.pop.data$pop.area.kind)) / length(census.de.100m.tile$internal.id), digits = 4) * 100)  %>% 
  mutate(class = factor(class)) %>% 
  arrange(desc(class)) %>% 
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop) 
 
tile.prop.plot <- prop.class %>% 
  ggplot(aes(x = "", y = prop, fill = class)) + 
  geom_bar(width = 1, stat = "identity", color = "white") + 
  scale_fill_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) +
  geom_text(aes(y = lab.ypos, label = paste0(prop, "%")), color = "black") +
  labs(x = "Class", y = "Number of tiles", title = "",
    subtitle = "Fig. 2b: Tile proportion") + 
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))
 
cluster.plot <- census.de.100m.tile %>%
  filter(pop.area.kind %in% c("Suburban", "Urban")) %>% 
  ggplot() +  
  geom_sf(aes(col = factor(pop.area.kind)), show.legend = F) + 
  ggtitle("", subtitle = "Clustering Results") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) +  
  scale_color_manual(breaks = c("Suburban", "Urban"), values = c("#117733", "#CC6677")) +
   labs(subtitle = "Fig. 2a: Clustering results") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(cluster.plot, tile.prop.plot, labels = "Fig.2 : Population Classification",  
            hjust = -0.1, label_size = 14, rel_widths = c(0.8, 1)) 
```
In Figure 2a, only the Suburban and Urban categories of tiles are represented and the transition from one category to another is highlighted thanks to the different colors used. It is possible to notice that there is an agglomeration of Urban tiles in correspondence to the important cities of South Bavaria, such as Munich. The Suburban tiles surround perfectly the Urban ones. 

The Figure 2b is a the stacked bar plot, that shows the proportions of the tiles according to the four categories. Based on our clustering algorithm, `r prop.class$prop[1]`% of the tiles are urban areas. `r prop.class$prop[2]`% of the tiles are uninhabited areas. `r prop.class$prop[3]`% of the tiles are suburban areas, and `r prop.class$prop[4]`% of the tiles are rural areas. As we can see, the largest percentage of tiles is inhabited. 

```{r pop distribution 2, fig.cap= "The Figure 3a shows the geographical distribution of the tiles classified thought the clustering algorithm of the population. In Figure 3b there is rapresented  the logarithm of ECCDF of the population data and the graph inside the figure 3b is the linear ECCDF." }

pop.dist.map.plot <- ECCDF.pop.data %>% 
  # sample_n(1000) %>%
  ggplot() + 
  geom_sf(aes(color = pop.area.kind), show.legend = F) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = " Fig. 3a : Geographic distribution") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm"), axis.text.x=element_text(angle=90, hjust=1)) 
 
ECCDF.pop.plot <- ECCDF.pop.data %>%   
  ggplot() + 
  geom_point(aes(x = log10.pop, y = log10.cum.prob.comp, 
                 color = pop.area.kind)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 1.5, y = -0.2, label = "50% of the data") + 
  geom_text(x = 1.5, y = -0.9, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = "Fig. 3b: Empirical cumulative complementary\ndistribution function") +  
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)",  
        colour = "") + 
  ylim(-7, 0) +
  theme(legend.position = "bottom") 
 
ECDF.pop.plot <- ECCDF.pop.data %>%   
  ggplot() + 
  geom_point(aes(x = pop.plot, y = cum.prob.comp, color = pop.area.kind)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  xlim(0, 30) +
  labs(y = "", x = "") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

pop.dist.ecdf.insert <- ECCDF.pop.plot +
  annotation_custom(ggplotGrob(ECDF.pop.plot), 
                    xmin = 0, xmax = 1.5, 
                    ymin = -7, ymax = -3)

plot_grid(pop.dist.map.plot, pop.dist.ecdf.insert, labels = "Fig. 3: Mobile phone density per tile",  
          hjust = -0.1, label_size = 14, rel_widths = c(0.8, 1))
```

Figure 3 shows the mobile phone density per tile in the focus area. In particular, we have 4 different colors representing the clusters: Uninhabited, Rural, Suburban and Urban.
Figure 3a confirms what we have written previously, in fact, the majority of the figure is yellow, which represents the Inhabitant tiles. It is possible to see the Urban tiles, which are red. But it is not possible to clearly distinguish Suburban and Rural tiles. Anyway, in Figure 2a, we have seen the detail of Urban and Suburban tiles. The Rural tiles are more distributed.

However, as we have already said, to have a deeper look of the mobile phone density per tile, we choose to represent the data with an empirical cumulative complementary distribution function (ECCDF) (using a log base 10 transformation).
The ECCDF is a step function with jumps `i/n` at observation values, where `i` is the number of tied observations at that value. Moreover, missing values are ignored and the objective "complementary" means that we need to subtract 1 - the cumulative probability. It is commonly used with variables that have a highly skewed distribution. We can see that this is the case - the population on this low spatial resolution is heavily right skewed.

As Figure 3b suggests with the presentation of the ECCDF, 50% of the data are represented by uninhabited tiles with no phones; furthermore, 90% of the tiles contain less than half of the mobile phones in our focus area. One can also see the tiles' classification based on the clustering results. Some tiles classified as Rural have higher values for their mobile phone population - this is because they are not considered as an Urban or Suburban cluster, as mentioned above. 10% left are tiles both Urban and Rural containing 0.5 and above mobile phones.


## Generation of a synthetic Radio Network

We generate a radio network, which is composed of three layers. The layers follow the pop.area.kind variable - layer 1 (Rural) spans over the rural, suburban and urban tiles, layer 2 (Suburban) spans over the suburban and urban tiles and layer 3 (Urban) is spanned over the urban tiles.

**Important features and parameters of the generated radio network are:**

-   The layers follow a hexagon shape with cell towers located in the respective centroid of each hexagon

-   Towers vary in distance to each other of the same layer, i.e. how far/close are towers of the same layer located to each other: layer 1 = 27,000m; layer 2 = 7000m; layer 3 = 900m (-\> the more urbanized, the closer the towers are too each other -\> denser coverage). Furthermore, hexagon independent rotation in terms of the first layer is executed: layer 2 = 35 degrees; layer 3 = 70 degrees

-   Each cell tower location is jittered in order to break the symmetry. The jitter amount depends on the layer: layer 1 = 5000m, layer 2 = 1000m, layer 3 = 400m.

-   Each tower contains three antennas pointing into 120 degree differing directions.

-   The layer determines the coverage diameter of an antenna: layer 1 = 15,000m; layer 2 = 2500m; layer 3 = 500m

-   Each tile of the focus area is sufficiently covered by at least one antenna and the antennas' coverage areas are allowed to overlap.

-   Parameters concerning the device to cell association are specified in the next section

The link to the source code for the layers.1 object as well as the coverage.areas.1 object is [here](https://github.com/R-ramljak/MNO_GM/blob/master/2_Radio%20cell%20generation.R).

The link to the source code for the layers object as well as the coverage.areas object is [here] (<https://github.com/R-ramljak/MNO_Eurostat/blob/master/code/2_Radio%20cell%20generation.R>).


We use a hexagonal structure to place towers across our focus area. This is a quite realistic setup for cell towers. Each hexagon corresponds to one tower which is originally placed in the centroid of the respective hexagon. In order to exclude symmetrical structure, we implement some randomness in the exact location of the cell towers. 

```{r network layers, fig.width = 7, fig.cap = "The figure presents the hexagonal structure. Each triangle is a tower location with some randomness implemented."}
layers <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/radio cell layers.rds") 
coverage.areas <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/coverage.areas.rds") 
 
coverage.layer1 <- coverage.areas %>%  
  filter(area.kind == "Rural") %>%  
  st_drop_geometry() %>%  
  dplyr::select(-antenna.centroid) %>%  
  st_as_sf(coords = c("X.tow", "Y.tow"), crs = 3035) 
 
layers.plot <- layers[[1]] %>% 
  st_as_sf(crs = 3035) %>%  
  ggplot() + 
    # geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
    #                                   xmin = xmin, xmax = xmax),  
    #         color = "black", size = 0.3, alpha = 0.5, fill = alpha("grey", 0)) + 
  geom_sf(linetype = "dotted") + 
  geom_sf(data = coverage.layer1, aes(color = "#4273C5"), shape = 17) + 
  scale_color_identity(name = "", 
                       # breaks = c("Focus area"), 
                       labels = c("Jittered tower location"), 
                       guide = "legend") + 
  labs(x = NULL, y = NULL,
       title = "",
    subtitle = "Towers are located in the centroid of a hexagon.") +
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
  plot.subtitle = element_text(size=9,hjust = 0.5))
   
plot_grid(layers.plot,
          labels = "Fig. 4:Radio network - Example Layer 1 (Rural)",
          hjust = -0.1, label_size = 14)
```

Figure 3 exemplifies the effect of the jitter parameter in the 1st layer, which covers the Rural tiles. The actual location deviates slightly from the centroid in order to break the symmetry of the underlying hexagonal structure. This is done for every layer.

The setup of a tower with its corresponding antennas is in every layer the same: Three antennas per tower, pointing into 120 degree differing directions. The animated visualization exemplifies this for any generic tower.

```{r animation}
knitr::include_graphics("https://github.com/R-ramljak/MNO_Eurostat/raw/master/antenna%20animation.gif")
```

Basically, a tower is generated at its specified location, then three antennas are created. For the operationalized data structure, the antenna location is not really relevant as it corresponds to the respective tower location. What is more important are the antennas' *coverage area centroids* because they describe the middle point of the then generated circular coverage area. The specific radius of any generic coverage area is layer specific and listed above. As indicated in the animation, an antenna specific coverage area is setup with a variable *coverage intensity profile*. Basically, cell phones that are closer to the coverage area centroid of any antenna, have a higher coverage probability, which will be later introduced as the *signal strength* parameter.

The following table presents the number of towers and the number of antennas of each layer (Rural, Urban and Suburban). More specifically, it is computed as a cumulative sum also the area in squared kilometers covered by each layers. 
The number of antennas is not always a perfect factor of 3 as the coverage areas are cropped according to the focus area. This means if the complete coverage area of an antenna lies outside of the focus area it is discarded.

```{r coverage areas 1}
tile.count <- census.de.100m.tile %>%  
  st_drop_geometry() %>% 
  group_by(pop.area.kind) %>%  
  summarise(area.in.sq.km = n() / 100) %>% 
  arrange(desc(pop.area.kind)) %>% 
  mutate(area.in.sq.km = case_when(pop.area.kind == "Rural" ~ cumsum(area.in.sq.km),
                                   pop.area.kind == "Suburban" ~ cumsum(area.in.sq.km),
                                   pop.area.kind == "Urban" ~ cumsum(area.in.sq.km))) %>% 
  arrange(pop.area.kind)

coverage.areas %>%  
  st_drop_geometry() %>%  
  group_by(area.kind, tower.ID) %>%  
  summarise(n.antenna = n(), .groups = "drop") %>%  
  ungroup() %>%  
  group_by(area.kind) %>%  
  summarise(n.tower = n(), 
            n.antenna = sum(n.antenna), .groups = "drop") %>%  
  left_join(tile.count, by = c("area.kind" = "pop.area.kind")) %>%  
  dplyr::select(layer = area.kind, n.tower, n.antenna, area.in.sq.km) %>%  
  kbl(caption = "Descriptive statistics per coverage layer") %>%
  kable_minimal() %>%
  footnote(general = "`area.in.sq.km` reports the actual area that was used for the generation of the coverage. Therefore, the first layer spans over the whole focus area, the second layer over the suburban and urban area, and the third layer over the urban area.")
```

As described in the parameter list above, Rural areas are covered only by layer 1, Suburban areas are covered by layer 1 and 2 and the urbanized areas are covered by all three layers. The average distance between multiple towers of the same layer decrease in layer 2 and layer 3 compared to layer 1. This leads to denser networks within these layers represented by the higher numbers of towers and therefore higher numbers of antennas in layer 2 and 3, given their area. The reason for this is that any generic antenna can only offer signal service to a limited amount of number of mobile phones. To cover all cell phones in more urbanized areas a denser radio cell network is needed in these areas.

The following figures present the actual coverage of each layer for the focus area.

```{r coverage areas 2, fig.cap = "The circles represent the coverage area of each antenna per layer. The signal density increases with increasing population density."}
coverage.area.plot <- coverage.areas %>%  
  ggplot() + 
  geom_sf(aes(col = area.kind), fill = NA) + 
  facet_grid(cols = vars(area.kind)) + 
  ggtitle("") + 
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  labs(x = NULL, y = NULL) +
  theme(axis.text.x=element_text(angle=90, hjust=1),plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(coverage.area.plot, labels = "Fig. 5: Coverage per layer",
          hjust = -0.1, label_size = 14) 
```

The interpretations of the Figure 5 above correspond to the level of coverage of each layer. It should be noticed that the antennas' coverage areas are allowed to overlap - with antennas of the same tower, as well as across towers of the same or another layer.

```{r coverage areas 3, fig.cap = "The figure on the left shows the geographical distribution of the tiles classified into the three layers based on the spatial clustering. On the right side, the coverage per layer is represented. The full coverage corresponds to the population density."}
# Implement shape of focus area

pop.dist.map.plot <- ECCDF.pop.data %>% 
  # sample_n(1000) %>%
  ggplot() + 
  geom_sf(aes(color = pop.area.kind), show.legend = F) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = " Fig. 6a : Geographic distribution") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm"), axis.text.x=element_text(angle=90, hjust=1)) 
 
coverage.area.full.plot <- coverage.areas %>% 
  ggplot() +
  geom_sf(aes(col = area.kind), fill = NA) +
  ggtitle("", subtitle = "Fig. 6b: Full coverage") +
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  theme(axis.text.x=element_text(angle=90, hjust=1),
        plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(pop.dist.map.plot, coverage.area.full.plot, labels = "Fig. 6: Full coverage corresponding to the density", 
          hjust = -0.1, label_size = 14)
```

Figure 6b presents the full network structure. By comparing the network structure to the tile density in Figure 6a we can see that full, partially overlapping coverage is granted for all areas and that the network layering structure follows suit with the true geographical population density.

```{r coverage intensity, fig.width = 7, fig.cap= paste0("The distribution is right skewed with a mean of ", round(mean(coverage.intensity$count), 2),", a minimum of ", min(coverage.intensity$count),", and a maximum of ", max(coverage.intensity$count)," antenna(s) per tile.")}
tiles.cat <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/coverage intensity.rds")
coverage.intensity <- tiles.cat %>%
  # left_join(census.de.100m.tile, by = "internal.id") %>% 
  # dplyr::select(internal.id, count, pop.area.kind) %>% 
  arrange(count) #%>%
  #mutate(prob = 1 / n()) %>%
  #mutate(cum.prob = cumsum(prob))

coverage.intensity.plot <- coverage.intensity %>%
  ggplot() +
  stat_count(aes(count), fill = "#4477A9") +
  geom_vline(xintercept = mean(coverage.intensity$count), linetype = "solid", color = "#117733", size = 1.5) +
  geom_vline(xintercept = median(coverage.intensity$count), linetype = "solid", color = "#CC6677", size = 1.5) +
  annotate("text", x = median(coverage.intensity$count) - 2, y = 5e+05, color = "#CC6677",
           label = paste("Median =", median(coverage.intensity$count))) +
  annotate("text", x = round(mean(coverage.intensity$count), 2) + 2, y = 5e+05, color = "#117733", 
           label = paste("Mean =", round(mean(coverage.intensity$count), 2))) +
  labs(y = "Count of tiles", x = "Covered by ... antennas", colour = "", title = "")
  # facet_grid(~pop.area.kind)
  
  
plot_grid(coverage.intensity.plot, labels = "Fig. 7: Number of antennas covering a tile",
          hjust = -0.1, label_size = 14)
```

Figure 7 shows a histogram representing the number of antennas per tile. The distribution is right skewed with a mean of `r round(mean(coverage.intensity$count), 2)`, a minimum of `r min(coverage.intensity$count)` and a maximum of `r max(coverage.intensity$count)` antenna(s) per tile. So, we have a median of `r median(coverage.intensity$count)` antennas per tile, which is a more robust measure than the mean that is driven by the extreme values. Even though the coverage areas were generated synthetically, this distribution mimics a realistic layout.

## Device-to-cell association

At this stage we have added to the geographically distributed mobile phone population a radio network, which is setup in three layers, spanning respectively across tiles that correspond to specific tile classification. (`pop.area.kind`).

The following module will establish the association between mobile phones of a generic tile to a relevant antenna. The result will be a reference matrix $P$ of size $I x J$, where I denotes the total number of radio cells (antennas), $J$ is the total number of tiles and the elements correspond to the probability of the mobile phones of any tile $j$ are registered in the cell $i$. With $P$ one is able to simulate the column vector $c$ (random variable) which describes the total count of mobile phone associated to a radio cell.

Assuming that $\mathcal{L}_{j}$ denotes the subset of radio cells covering a particular tile (remember, overlapping coverage areas are very common). This means that these respective radio cells are competing with each other to be associated with the cell phones in the tile. We therefore assign probabilities which describe the respective association between a radio cell $i$ and tile $j$. This probability depends on the parameter signal strength which we mimic with a simple linear function that describes the gradual decrease in signal the further away the tile centroid $j$ is from the coverage area centroid of $i$:

$$
s_{ij} = \frac{d_{ij}}{r_{i}}
$$

We basically calculate the distance between the two centroids, $d_{ij}$, and divide it between the radius of that radio cell, $r_{i}$- it is denoted by $s_{ij}$. We introduce a minimum threshold value $\nu$ which limits radio cells with a too low signal intensity $s_{ij}$ for a particular tile to be able to be picked up by a mobile phone in that tile - resulting in the minimum value of 0. We also introduce a maximum threshold, describing tiles that are very close to the coverage area centroid, i.e. a high value for $s_{ij}$ -- when passing this threshold their respective $s_{ij}$ values result in the maximum value 1. This particular operationalization of a function modeling the signal strength parameter instead of fixed categorical signal strength values makes the overall workflow of the notebook more realistic (granularity) and more modular as one can later implement very easy even more realistic functions describing the signal strength parameter. In this scenario we have implemented a minimum threshold of $\nu = 0.01$ and a maximum threshold of $\zeta = 0.01$ depending on $r_{i}$. The exact operationalization can be found [here](https://github.com/R-ramljak/MNO_GM/blob/master/3_device%20to%20cell.R).

The elements of $P$ - the probability with which the mobile phones within a particular cell are associated with a particular radio cell - are defined by

$$
p_{ij} = \frac{s_{ij}}{\sum_{i \in \mathcal{L}_{j}} s_{ij}}
$$

where $s_{ij}$ describes the signal intensity of a particular cell $i$ associated with a particular tile $j$, and $\mathcal{L}_{j}$ describes the subset of radio cells that are covering the tile $j$. We then simulate the tile specific experiments - every mobile phone within a tile will be independently assigned to relevant radio cell with the probability $p_{ij}$. The result is the column vector $c$ which will act as a reference for the later on introduced estimation strategies.

```{r c.vector.distribution, fig.cap= "Mobile devices are predominately associated with Layer 1 antennas."}
C.vec.df <- readRDS("C:/Users/luigi/Documents/MNO_Stefania/C.vec.df.final.new.rds")
# ECCDF of population distribution 
ECCDF.phones.data <- C.vec.df %>% 
  mutate(layer = case_when(str_detect(antenna.ID, "RT") ~ "Layer 1",
                           str_detect(antenna.ID, "ST") ~ "Layer 2",
                           str_detect(antenna.ID, "UT") ~ "Layer 3")) %>% 
  arrange(phones.sum) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>% 
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.phones = log10(phones.sum))

ECCDF.phones.plot <- ECCDF.phones.data %>%   
  ggplot() + 
  geom_point(aes(x = log10.phones, y = log10.cum.prob.comp, 
                 color = layer)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 4, y = -0.15, label = "50% of the data") + 
  geom_text(x = 4, y = -0.85, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Layer 1", "Layer 2", "Layer 3")) + 
  ylim(-4, 0) +
  ggtitle("") +
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)", colour = "")+
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
        plot.subtitle = element_text(size=9,hjust = 0.5))
ECDF.phones.plot <- ECCDF.phones.data %>%   
  ggplot() + 
  geom_point(aes(x = phones.sum, y = cum.prob.comp, color = layer)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  labs(y = "", x = "") +
  xlim(0, 8000) +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())
pop.dist.ecdf.insert <- ECCDF.phones.plot +
  annotation_custom(ggplotGrob(ECDF.phones.plot), 
                    xmin = 0, xmax = 2, 
                    ymin = -4, ymax = -1.5)
    
plot_grid(pop.dist.ecdf.insert, labels = "Fig. 8: ECCDF Device-to-cell association",  hjust = -0.1, label_size = 14)
```

Once again, we use the ECCDF with log10 to understand the distribution of the device-to-cell association. 50% of the devices is associated to the cells in the Rural layer. Furthermore, 90% of the devices are associated only to cells of layer 1 and layer 2, respectively Rural and Suburban. ONly 10% of the devices are assocaited also to the layer 3, which Urban. 


```{r c.vector special cases, fig.width = 7, fig.cap = "These antennas have more than 10,000 mobile devices associated to themselves. They all belong to layer 1 and are located close or within urban centers."}

extreme.antennas.plot <- C.vec.df %>%  
  filter(phones.sum >= 10000) %>% 
  left_join(coverage.areas, by = "antenna.ID") %>% 
  st_as_sf() %>% 
  ggplot() + 
  geom_sf(aes(col = area.kind), fill = NA) + 
  ggtitle("") + 
  scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  labs(x = NULL, y = NULL) +
  theme(axis.text.x=element_text(angle=90, hjust=1),plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(extreme.antennas.plot, labels = "Fig. 9: Extreme antennas",
          hjust = -0.1, label_size = 14) 
```

