[["estimation-strategies-1.html", "5 Estimation Strategies", " 5 Estimation Strategies We have implemented two specific estimation strategies: Voronoi tessellation (tower locations OR coverage area centroids as seeds) MLE Poisson All three of these estimation techniques produce a tile specific estimate. The sum of these estimates always equals the sum of the c.vector, i.e. all registered mobile phones. This characteristic explains the strategy of all of these estimators: Taking the complete number of registered phones in the c.vector and allocating them across all the tiles. There is however a fundamental difference between the two estimators: The second one allows for the realistic setting of overlapping antenna coverage. As shown above there are many tiles that are covered by multiple antennas. Current research suggests that this can result in more accurate estimations. "],["voronoi-tesselation-1.html", "5.1 Voronoi tesselation", " 5.1 Voronoi tesselation Voronoi tessellation uses seeds to calculate Voronoi regions. For every seed there is one Voronoi region that contains the area that is closest to the particular seed. There are two seed specifications we are interested in: Tower locations as seeds –&gt; n = 1289 Coverage area centroid (per antenna) locations as seeds –&gt; n = 3841 Below we specify the tower locations as seed points. These are then used to compute the Voronoi regions. Before we do that we need to make sure that the corresponding c.vector is aggregated on the tower level. We then join the Voronoi regions with the tiles to create an object that links tiles within respective Voronoi regions. 5.1.1 Setup of necessary datasets For any kind of Voronoi tessellation we need to work with the grid level data (tiles) and the cell coverage data (tower, antennas). census.de.100m.tile &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/census.tile.final.rds&quot;) coverage.areas &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/coverage.areas.rds&quot;) c.vec &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/C.vec.df.final.new.rds&quot;) ## derive the shape of the focus area # census.geo.body &lt;- census.de.100m.tile %&gt;% # select(internal.id) %&gt;% # summarise(geometry = st_union(geometry)) # saveRDS(census.geo.body, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/shape.focusarea.rds&quot;) census.geo.body &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/shape.focusarea.rds&quot;) # adding to the coverage areas the results of the c vector coverage.areas.comp &lt;- coverage.areas %&gt;% left_join(c.vec, by = &quot;antenna.ID&quot;) %&gt;% mutate(phones.sum = case_when(is.na(phones.sum) ~ 0, TRUE ~ phones.sum)) # select only the internal id and the mobile phone population per tile census.de.100m.tile.pop &lt;- census.de.100m.tile %&gt;% dplyr::select(internal.id, pop) # aggregating the antennas to towers (and corresponding values) and identifying problematic tower locations (outside of focus area) tower.aggr &lt;- coverage.areas.comp %&gt;% st_drop_geometry() %&gt;% group_by(tower.ID) %&gt;% mutate(phones.sum = sum(phones.sum)) %&gt;% distinct(tower.ID, .keep_all = T) %&gt;% ungroup() %&gt;% dplyr::select(tower.ID, X.tow, Y.tow, phones.sum) %&gt;% st_as_sf(coords = c(&quot;X.tow&quot;, &quot;Y.tow&quot;)) %&gt;% st_sf(crs = 3035) %&gt;% mutate(within.fa = lengths(st_within(., census.geo.body))) # find seeds outside the focus area # saving towerIDs of problematic towers towers.outside.ID &lt;- tower.aggr %&gt;% filter(within.fa == 0) %&gt;% dplyr::select(tower.ID) %&gt;% deframe() # filtering unproblematic towers towers.inside &lt;- tower.aggr %&gt;% filter(within.fa == 1) # Finding respective nearest point on focus area border for every problematic tower location and binding the unproblematic towers back # this object contains the final seed locations in the geometry towers.final.data &lt;- tower.aggr %&gt;% filter(within.fa == 0) %&gt;% st_nearest_points(., census.geo.body) %&gt;% st_cast(&quot;POINT&quot;) %&gt;% .[seq(2, length(.), 2)] %&gt;% # st_as_sf() %&gt;% mutate(tower.ID = towers.outside.ID) %&gt;% mutate(geometry = x) %&gt;% st_sf(sf_column_name = &quot;geometry&quot;) %&gt;% dplyr::select(-x) %&gt;% bind_rows(towers.inside) sum(unlist(st_intersects(towers.final.data, census.geo.body))) == length(tower.aggr$tower.ID) # check if all are within now # Using the seed object to calculate the Voronoi regions tower.seed.voronoi &lt;- towers.final.data %&gt;% st_geometry() %&gt;% st_union() %&gt;% st_voronoi() %&gt;% st_collection_extract(type = &quot;POLYGON&quot;) %&gt;% st_sf(crs = 3035) %&gt;% st_join(tower.aggr) %&gt;% # rejoin with seed object to retain seed id st_intersection(census.geo.body) %&gt;% mutate(category.log = log10(phones.sum / as.numeric(st_area(geometry)))) %&gt;% mutate(category = cut(category.log, c(-6, -4, -2, -1), right = F, ordered_result = T)) And now the same preparation for the coverage area centroids (here also just “antennas” even though this is imprecise). ### antennas # aggregating the antennas to towers (and corresponding values) and identifying problematic tower locations (outside of focus area) antenna.aggr &lt;- coverage.areas.comp %&gt;% st_drop_geometry() %&gt;% dplyr::select(antenna.ID, geometry = antenna.centroid, phones.sum) %&gt;% st_sf() %&gt;% st_sf(crs = 3035) %&gt;% mutate(within.fa = lengths(st_within(., census.geo.body))) # find seeds outside the focus area # saving towerIDs of problematic antennas antennas.outside.ID &lt;- antenna.aggr %&gt;% filter(within.fa == 0) %&gt;% dplyr::select(antenna.ID) %&gt;% deframe() # filtering unproblematic antennas antennas.inside &lt;- antenna.aggr %&gt;% filter(within.fa == 1) # Finding respective nearest point on focus area border for every problematic antenna location and binding the unproblematic towers back # this object contains the final seed locations in the geometry antennas.final.data &lt;- antenna.aggr %&gt;% filter(within.fa == 0) %&gt;% st_nearest_points(., census.geo.body) %&gt;% st_cast(&quot;POINT&quot;) %&gt;% .[seq(2, length(.), 2)] %&gt;% # st_as_sf() %&gt;% mutate(antenna.ID = antennas.outside.ID) %&gt;% mutate(geometry = x) %&gt;% st_sf(sf_column_name = &quot;geometry&quot;) %&gt;% dplyr::select(-x) %&gt;% bind_rows(antennas.inside) # sum(unlist(st_intersects(antennas.final.data, census.geo.body))) == length(antenna.aggr$antenna.ID) # check if all are within now # Using the seed object to calculate the Voronoi regions antenna.seed.voronoi &lt;- antennas.final.data %&gt;% st_geometry() %&gt;% st_union() %&gt;% st_voronoi() %&gt;% st_collection_extract(type = &quot;POLYGON&quot;) %&gt;% st_sf(crs = 3035) %&gt;% st_join(antenna.aggr) %&gt;% # rejoin with seed object to retain seed id st_intersection(census.geo.body) %&gt;% mutate(category.log = log10(phones.sum / as.numeric(st_area(geometry)))) %&gt;% mutate(category = cut(category.log, c(-6, -4, -2, -1), right = F, ordered_result = T)) # check density values # antenna.seed.voronoi %&gt;% # ggplot() + # geom_density(aes(category.log)) # Visualizing the Vornoi regions with respective phone count VT.plot &lt;- tower.seed.voronoi %&gt;% ggplot() + geom_sf(aes(fill = category), size = 0.001) + scale_fill_ptol(na.translate = FALSE) + scale_color_ptol(na.translate = FALSE) + guides(color = F) + labs(fill = &quot;Local density\\n(log10)&quot;) + ggtitle(&quot;&quot;, subtitle = &quot;Tower locations as seeds&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.title = element_text(size = 10, face = &quot;bold&quot;, hjust = 0.5), plot.subtitle = element_text(size = 9, hjust = 0.5)) saveRDS(VT.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/VT.plot.rds&quot;) VA.plot &lt;- antenna.seed.voronoi %&gt;% ggplot() + geom_sf(aes(fill = category), size = 0.001) + scale_fill_ptol(na.translate = FALSE) + scale_color_ptol(na.translate = FALSE) + guides(color = F) + labs(fill = &quot;Local density\\n(log10)&quot;) + ggtitle(&quot;&quot;, subtitle = &quot;Coverage area centroid locations as seeds&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.title = element_text(size = 10, face = &quot;bold&quot;, hjust = 0.5), plot.subtitle = element_text(size = 9, hjust = 0.5)) saveRDS(VA.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/VA.plot.rds&quot;) plot_grid(VT.plot, VA.plot, labels = &quot;Fig. 10: Voronoi tower estimation&quot;, hjust = -0.1, label_size = 14) We have now created the Voronoi regions for our focus area with tower locations as seeds as well as with antenna respective coverage area centroid locations as seeds. The number of seeds and Voronoi regions align with each other. The spatial density per tile can be expressed as the ratio of the mobile phones in that region and the area of the Voronoi region: \\(d_{k} = \\frac{\\sum c_{i}} {A_{k}}\\) This region specific estimand corresponds to the tile estimate for a tile that is contained in this region. On the tile level there can be two cases that we need to differentiate: Tiles that are completely contained within one Voronoi region Tiles that intersect with two or more Vornoi regions For the first case, the tile specific estimate corresponds to \\(d_{k}\\). For the second case we will calculate a weighted mean of the relevant Voronoi region estimates by using the corresponding tile area within each Voronoi region as weights. # spatial densities per Voronoi region tower.voronoi.est &lt;- tower.seed.voronoi %&gt;% mutate(area = as.numeric(st_area(.$geometry))) %&gt;% mutate(voronoi.est = phones.sum / area) # the sum of the product of this and the area is the total pop # Joining the regions with the tile specific data tower.seed.voronoi.join &lt;- tower.voronoi.est %&gt;% st_join(census.de.100m.tile.pop) %&gt;% # &amp; re-connect the data items st_set_agr(&quot;aggregate&quot;) %&gt;% # clean up group_by(internal.id) %&gt;% mutate(count = n()) %&gt;% ungroup() # identifiying tiles intersecting with multiple Voronoi regions tower.multiple &lt;- tower.seed.voronoi.join %&gt;% st_drop_geometry() %&gt;% filter(count &gt; 1) %&gt;% distinct(internal.id) %&gt;% deframe() # calculate area within competing voronoi regions of &quot;multiple&quot; tiles tower.intersect.tiles &lt;- census.de.100m.tile.pop %&gt;% filter(internal.id %in% tower.multiple) %&gt;% st_intersection(tower.voronoi.est) %&gt;% st_collection_extract(type = &quot;POLYGON&quot;) %&gt;% # select the polygons mutate(amount.tiles = as.numeric(st_area(.$geometry)) / 10000) # checked if it adds up to 1 example.helper &lt;- tower.intersect.tiles %&gt;% filter(internal.id == &quot;342403&quot;) %&gt;% select(tower.ID) %&gt;% deframe() And now the same again for the antennas. # spatial densities per Voronoi region antenna.voronoi.est &lt;- antenna.seed.voronoi %&gt;% mutate(area = as.numeric(st_area(.$geometry))) %&gt;% mutate(voronoi.est = phones.sum / area) # the sum of the product of this and the area is the total pop # Joining the regions with the tile specific data antenna.seed.voronoi.join &lt;- antenna.voronoi.est %&gt;% st_join(census.de.100m.tile.pop) %&gt;% # &amp; re-connect the data items st_set_agr(&quot;aggregate&quot;) %&gt;% # clean up group_by(internal.id) %&gt;% mutate(count = n()) %&gt;% ungroup() # identifiying tiles intersecting with multiple Voronoi regions antenna.multiple &lt;- antenna.seed.voronoi.join %&gt;% st_drop_geometry() %&gt;% filter(count &gt; 1) %&gt;% distinct(internal.id) %&gt;% deframe() # calculate area within competing voronoi regions of &quot;multiple&quot; tiles antenna.intersect.tiles &lt;- census.de.100m.tile.pop %&gt;% filter(internal.id %in% antenna.multiple) %&gt;% st_intersection(antenna.voronoi.est) %&gt;% st_collection_extract(type = &quot;POLYGON&quot;) %&gt;% # select the polygons mutate(amount.tiles = as.numeric(st_area(.$geometry)) / 10000) # checked if it adds up to 1 We can now calculate the estimated spatial density per tile. #### Towers # final datatset to calculate spatial density tower.voronoi.final &lt;- tower.intersect.tiles %&gt;% st_drop_geometry() %&gt;% select(internal.id, tower.ID, amount.tiles) %&gt;% right_join(tower.seed.voronoi.join, by = c(&quot;internal.id&quot;, &quot;tower.ID&quot;)) %&gt;% mutate(amount.tiles = case_when(is.na(amount.tiles) ~ 1, TRUE ~ amount.tiles)) %&gt;% group_by(internal.id) %&gt;% mutate(voronoi.est.tower = weighted.mean(x = voronoi.est, w = amount.tiles) * 10000) %&gt;% distinct(internal.id, voronoi.est.tower) # should result in same length as the raw tiles object and the sum of the vornoir est corrected should resemble the sum of the c.vec #### antennas # final datatset to calculate spatial density antenna.voronoi.final &lt;- antenna.intersect.tiles %&gt;% st_drop_geometry() %&gt;% select(internal.id, antenna.ID, amount.tiles) %&gt;% right_join(antenna.seed.voronoi.join, by = c(&quot;internal.id&quot;, &quot;antenna.ID&quot;)) %&gt;% mutate(amount.tiles = case_when(is.na(amount.tiles) ~ 1, TRUE ~ amount.tiles)) %&gt;% group_by(internal.id) %&gt;% mutate(voronoi.est.corrected = weighted.mean(x = voronoi.est, w = amount.tiles) * 10000) %&gt;% distinct(internal.id, voronoi.est.corrected, pop) # should result in same length as the raw tiles object and the sum of the vornoir est corrected should resemble the sum of the c.vec voronoi.final.both &lt;- antenna.voronoi.final %&gt;% mutate(voronoi.est.antenna = voronoi.est.corrected) %&gt;% select(-voronoi.est.corrected) %&gt;% left_join(tower.voronoi.final, by = &quot;internal.id&quot;) saveRDS(voronoi.final.both, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Voronoi both/Voronoi.estimates.rds&quot;) In this chunk of code, we will then create the plots. ## data prep and plot: Voronoi Tower estimations.Voronoi.both &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Voronoi both/Voronoi.estimates.rds&quot;) # read in the data estimations.VT &lt;- estimations.Voronoi.both %&gt;% ungroup() %&gt;% select(internal.id, voronoi.est.tower) %&gt;% mutate(pop.cat = case_when(voronoi.est.tower &lt;= 1 ~ &quot;Less or equal 1&quot;, voronoi.est.tower &gt; 1 &amp; voronoi.est.tower &lt;= 10 ~ &quot;Between 2 and 10&quot;, voronoi.est.tower &gt; 10 &amp; voronoi.est.tower &lt;= 30 ~ &quot;Between 11 and 30&quot;, voronoi.est.tower &gt; 30 ~&quot;More than 30&quot;)) %&gt;% mutate(mobile = factor(pop.cat, levels = c(&quot;Less or equal 1&quot;, &quot;Between 2 and 10&quot;, &quot;Between 11 and 30&quot;, &quot;More than 30&quot;))) %&gt;% arrange(internal.id) %&gt;% mutate(geometry = census.geo$geometry) %&gt;% select(internal.id, mobile, geometry) %&gt;% st_as_sf() %&gt;% group_by(mobile) %&gt;% summarise(geometry = st_union(geometry)) saveRDS(estimations.VT, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Plot.files/VT.estimate_data.rds&quot;) VT.plot &lt;- estimations.VT %&gt;% ggplot() + geom_sf(aes(fill = factor(mobile), color = factor(mobile))) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;&quot;, subtitle = &quot;Voronoi tower estimate&quot;, size = 20) + scale_fill_ptol(name = &quot;Mobile phones&quot;) + scale_color_ptol(guide = F) saveRDS(VT.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Plot.files/VT.estimate_map.rds&quot;) ## data prep and plot: Voronoi antenna estimations.Voronoi.both &lt;- readRDS(&quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Voronoi both/Voronoi.estimate.rds&quot;) estimations.VA &lt;- estimations.Voronoi.both %&gt;% ungroup() %&gt;% select(internal.id, voronoi.est.antenna) %&gt;% mutate(pop.cat = case_when(voronoi.est.antenna &lt;= 1 ~ &quot;Less or equal 1&quot;, voronoi.est.antenna &gt; 1 &amp; voronoi.est.antenna &lt;= 10 ~ &quot;Between 2 and 10&quot;, voronoi.est.antenna &gt; 10 &amp; voronoi.est.antenna &lt;= 30 ~ &quot;Between 11 and 30&quot;, voronoi.est.antenna &gt; 30 ~ &quot;More than 30&quot;)) %&gt;% mutate(mobile = factor(pop.cat, levels = c(&quot;Less or equal 1&quot;, &quot;Between 2 and 10&quot;, &quot;Between 11 and 30&quot;, &quot;More than 30&quot;))) %&gt;% arrange(internal.id) %&gt;% mutate(geometry = census.geo$geometry) %&gt;% select(internal.id, mobile, geometry) %&gt;% st_as_sf() %&gt;% group_by(mobile) %&gt;% summarise(geometry = st_union(geometry)) saveRDS(estimations.VA, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Plot.files/VA.estimate_data.rds&quot;) VA.plot &lt;- estimations.VA %&gt;% ggplot() + geom_sf(aes(fill = factor(mobile), color = factor(mobile))) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;&quot;, subtitle = &quot;Voronoi antenna estimate&quot;, size = 20) + scale_fill_ptol(name = &quot;Mobile phones&quot;) + scale_color_ptol(guide = F) saveRDS(VA.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/Estimates/Plot.files/VA.estimate_map.rds&quot;) # Plot read in VT.plot &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/working objects/VT.plot.rds&quot;) VA.plot &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/working objects/VA.plot.rds&quot;) VT.plot VA.plot # plot_grid(VT.plot, VA.plot, labels = &quot;Fig. 10: Voronoi tower estimation&quot;, hjust = -0.1, label_size = 14) (#fig:voronoi antenna and tower prep plot)The tower centroids were used as seeds for the creation of the Voronoi regions. The color scale is defined by the log with base 10 local density i.e. the absolute number of mobile phones within a Voronoi region divided by absolute area of the respecitve Voronoi region. We have now created the Voronoi regions for our focus area with tower locations as seeds as well as with antenna respective coverage area centroid locations as seeds. The number of seeds and Voronoi regions align with each other. The spatial density per tile can be expressed as the ratio of the mobile phones in that region and the area of the Voronoi region: \\(d_{k} = \\frac{\\sum c_{i}} {A_{k}}\\) This region specific estimate corresponds to the tile estimate for a tile that is contained in this region. On the tile level there can be two cases that we need to differentiate: Tiles that are completely contained within one Voronoi region Tiles that intersect with two or more Vornoi regions For the first case, the tile specific estimate corresponds to \\(d_{k}\\). For the second case we will calculate a weighted mean of the relevant Voronoi region estimates by using the corresponding tile area within each Voronoi region as weights. # example plot VT.bird.example.plot &lt;- tower.intersect.tiles %&gt;% filter(internal.id == &quot;342403&quot;) %&gt;% ggplot() + geom_sf(color = &quot;black&quot;) + geom_sf(data = (census.de.100m.tile %&gt;% filter(internal.id == &quot;342403&quot;)), color = &quot;red&quot;, fill = NA) + geom_sf(data = (tower.seed.voronoi %&gt;% filter(tower.ID %in% example.helper)), fill = NA) + ggtitle(&quot;&quot;, subtitle = &quot;Birds view of a tile that intersects with multiple regions&quot;) saveRDS(VT.bird.example.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/VT.bird.example.plot.rds&quot;) VT.example.plot &lt;- tower.intersect.tiles %&gt;% filter(internal.id == &quot;342403&quot;) %&gt;% ggplot() + geom_sf() + # add description and scales geom_sf_label(aes(label = tower.ID)) + geom_sf_text(aes(label = paste0(&quot;(&quot;, round(amount.tiles, 2), &quot;)&quot;)), nudge_y = -7) + geom_sf(data = (census.de.100m.tile.pop %&gt;% filter(internal.id == &quot;342403&quot;)), color = &quot;red&quot;, fill = NA) + ggtitle(&quot;&quot;, subtitle = &quot;Relative area per Voronoi region&quot;) saveRDS(VT.example.plot, &quot;Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/VT.example.plot.rds&quot;) plot_grid(VT.bird.example.plot, VT.example.plot, labels = &quot;Fig. 11: Example multiple tile&quot;, hjust = -0.1, label_size = 14) VT.bird.example.plot &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/working objects/VT.bird.example.plot.rds&quot;) + theme(axis.text.x=element_text(angle=90, hjust=1)) VT.example.plot &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/working objects/VT.example.plot.rds&quot;) + theme(axis.text.x=element_text(angle=90, hjust=1)) VT.bird.example.plot VT.example.plot # plot_grid(VT.bird.example.plot, VT.example.plot, # labels = &quot;Fig. 11: Example multiple tile&quot;, hjust = -0.1, label_size = 14) (#fig:Voronoi tower multiples)This is an example of a tile that intersects with multiple Voronoi regions. The labels and number correspond to the Voronoi region and the given area that are used as weights for the weighted mean estimator. Here we visualize the second case with an example tile and example Voronoi regions from the Voronoi with tower locations as seeds. In the left plot we can see a small tile that is indicated in red. This tile is at the intersection of 4 Voronoi regions. The corresponding relative tile area intersecting with each Voronoi region can be seen in the right plot. The labels correspond to the Voronoi region ID and the below in brackets indicate the proportional weight that should be considered in calculting the tile specific weighted mean estimate. To compare this to the first case - where a tile is fully contained only in one region - the weight for the particular Voronoi region is 1. The same methodogolgy is pursued for the Voronoi antenna case. "],["mle-poisson-1.html", "5.2 MLE Poisson", " 5.2 MLE Poisson MLE Poisson: \\(\\hat{u}^{m+1}_{j} = \\hat{u}^{m}_{j}\\sum_{i = 1}^{I} c_{i} \\frac{p_{ij}}{\\sum_{k = 1}^{J} p_{ik} \\hat{u}^{m}_{k}}\\) Talk about the difference between MLE True and Equal. "]]
