<<<<<<< HEAD
[["test.html", "8 test", " 8 test # change accordingly knitr::opts_knit$set(root.dir = normalizePath(&quot;/Users/Marco/Vysoká kola ekonomická v Praze/Tony Wei Tse Hung - YAY&quot;)) knitr::opts_chunk$set(fig.width = 9) knitr::opts_knit$set(eval.after = &quot;fig.cap&quot;) library(tidyverse) library(sf) library(raster) library(Matrix) library(knitr) library(kableExtra) library(ggthemes) set.seed(762) census.de.100m.tile &lt;- readRDS(&quot;working objects/census.tile.final.rds&quot;) # Bounding box of focus area bb.focus.dat &lt;- data.frame(xmin = 4400000, xmax = 4500000, ymin = 2700000, ymax = 2900000) bb.focus.vec &lt;- c(xmin = 4400000, xmax = 4500000, ymin = 2700000, ymax = 2900000) # Download data from : https://gadm.org/download_country_v3.html --&gt; R(sf) level 1 germany.raw &lt;- readRDS(&quot;working objects/gadm36_DEU_1_sf.rds&quot;) germany &lt;- germany.raw %&gt;% st_transform(crs = 3035) focus.area.plot &lt;- germany %&gt;% ggplot() + geom_sf() + geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax, color = &quot;red&quot;), size = 1, fill = &quot;transparent&quot;) + ggtitle(&quot;&quot;) + scale_color_identity(name = &quot;&quot;, labels = c(&quot;Focus area&quot;), guide = &quot;legend&quot;) + labs(x = NULL, y = NULL, title = &quot;&quot;) focus.area.plot Figure 8.1: We will only focus on a subset of the tiles located in the state of Bavaria because it comprises both urban, suburban, and rural areas "]]
=======
[["appendix-a-a-deep-dive-into-the-convergence-behaviour-of-mle-estimates.html", "8 Appendix A: A deep dive into the convergence behaviour of MLE estimates", " 8 Appendix A: A deep dive into the convergence behaviour of MLE estimates In the course of our work we thought it was particularly interesting to further focus on the actual convergence behavior of the MLE-based estimators. By this, we want to see how the estimators evolve after each iteration. We will visualize the convergence behavior/the evolution of the estimates up to 1000 iterations. This is executed based on a stratified sample (strata: three level pop.area.kind variable), n = 150). We measure this convergence behavior through the use of MAD and AAD which was explained in chapter 5. We calculate the AAD and MAD for each iteration and see how estimates evolve, as the iterations increase. Average Absolute Discrepancy (AAD): \\(D_{avg}(u,v) = \\frac{1}{U}\\sum_{j = 1}^{J} |u_{j} - v_{j}|\\) Maximum Absolute Discrepancy (MAD): \\(D_{max}(\\textbf{u,v}) \\overset{\\underset{\\mathrm{def}}{}}{=} \\sum_{\\mathit{j = 1}}^{\\mathit{J}}\\left | u_{j} - v_{j} \\right |\\) "],["discrepancy-measures-per-iteration-1.html", "8.1 Discrepancy measures per iteration", " 8.1 Discrepancy measures per iteration # In this section we will be calculating the AAD and MAD values for the true population matrix # First get the true population vector from another dataset voro &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/Voronoi both/Voronoi.estimates.rds&quot;) # getting the true pop vector from another object pop = voro$pop voro = voro %&gt;% ungroup() # Calculating Average Absolute Discrepancy # Because the data is in three parts, thus we will calculate the AAD separately. The first set has iterations between 0 and 400. The second set has iterations between 401 and 801. The third set has iterations between 802 and 1002. # The code/procedure is rather similar to the statistical evaluation presented in chapter 5, except that over here we are looking at all of the iterations instead of the last iteration. # Note: the graphing part might take a bit longer to render. # Part one equal1 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.equal/u.est.non.inf.P.equal.part1_400_new.rd s&quot; ) #read in the data equal1 = cbind(equal1, pop) # combining the data frame with the population vector bigu = sum(equal1$pop) # useful to have this calculated and stored as a constant already aad1 = equal1 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) # summing up all rows for each column colnames(aad1) = 0:400 # change the column names # Part two equal2 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.equal/u.est.non.inf.P.equal.part401_800_new.rds&quot;) # read in the data equal2 = cbind(equal2,pop) # combining the data frame with the population vector aad2 = equal2 %&gt;% # mutating transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) colnames(aad2) = 401:801 # change the column names # Part three equal3 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.equal/u.est.non.inf.P.equal.part801_1000_new.rds&quot;) # read in the data equal3 = cbind(equal3,pop) # combining the data frame with the population vector aad3 = equal3 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) # summing up all rows for each column colnames(aad3) = 802:1002 # change the column names aad = cbind(aad1,aad2,aad3) # now we merge all three parts together in one aadt = aad %&gt;% pivot_longer(-c(), names_to = &quot;iter&quot;, values_to = &quot;aad&quot;) # transform the data frame into the long format aadt$iter = as.numeric(aadt$iter) # cast the `iter` variable as a numeric variable # Plot using ggplot equal.aad.plot = aadt %&gt;% ggplot(aes(x = iter, y = aad)) + geom_line() + labs(x = &quot;Number of Iteration&quot;, y = &quot;Average Absolute Discrepancy&quot;, title = &quot;Equal Probability Matrix ~ AAD&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(equal.aad.plot, file = &quot;equal.aad.plot.rds&quot;) # save the plot as rds # Calculating Maximum Absolute Discrepancy # Part One mad1 = equal1 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad1) = 0:400 # change the column names # Part Two mad2 = equal2 %&gt;% # mutating transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad2) = 401:801 # change the column names # Part Three mad3 = equal3 %&gt;% # mutating transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad3) = 802:1002 # change the column names mad = cbind(mad1,mad2,mad3) # now we merge all three parts together in one madt = mad %&gt;% pivot_longer(-c(),names_to = &quot;iter&quot;, values_to = &quot;mad&quot;) # transform the data frame into the long format madt$iter = as.numeric(madt$iter) # cast the `iter` variable as a numeric variable # Plot using ggplot equal.mad.plot = madt %&gt;% ggplot(aes(x = iter, y = mad)) + geom_line() + labs(x = &quot;Number of Iteration&quot;, y = &quot;Maximum Absolute Discrepancy&quot;, title = &quot;Equal Probability Matrix ~ MAD&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(equal.mad.plot, file = &quot;equal.mad.plot.rds&quot;) # save the plot as rds For the equal population matrix, the discrepancy values stabilizes as the number of iterations increases. Specifically, starting at the 700th iteration, the discrepancy values are largely the same. # In this section we will be calculating the AAD and MAD values for the true population matrix. # This part is the largely the same procedure as the above section when calculating the equal population matrix. # NOte: due to memory shortage, I have actively remove unused objects in order to conserve as much memory as possible. I also used as much of the garbage collection function, gc(), as possible. rm(list = ls()) # remove unused objects voro &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/Voronoi both/Voronoi.estimates.rds&quot;) # getting the true pop vector from another object pop = voro$pop rm(voro) # Calculating Average Absolute Discrepancy # Part One true1 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part1_400_new.rds&quot;) # read in the data true1 = cbind(true1,pop) # combining the data frame with the population vector bigu = sum(true1$pop) # useful to have this calculated and stored as a constant already aad1 = true1 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) # summing up all rows for each column colnames(aad1) = 0:400 # change column names rm(true1) # remove unnecessary object # Part Two true2 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part401_800_new.rds&quot;) # read in the data true2 = cbind(true2,pop) # combining the data frame with the population vector aad2 = true2 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) # summing up all rows for each column colnames(aad2) = 401:801# change column names rm(true2)# remove unnecessary object # Part Three true3 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part801_1000_new.rds&quot;) # read in the data true3 = cbind(true3,pop) # combining the data frame with the population vector aad3 = true3 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.)/bigu)) # summing up all rows for each column colnames(aad3) = 802:1002 # change column names rm(true3)# remove unnecessary object aad = cbind(aad1,aad2,aad3) # combining all three parts together in one data frame aadt = aad %&gt;% pivot_longer(-c(), names_to = &quot;iter&quot;, values_to = &quot;aad&quot;) # Transform the data frame into long form aadt$iter = as.numeric(aadt$iter) # cast the `iter` variable as a numeric variable # Plot using ggplot true.aad.plot = aadt %&gt;% ggplot(aes(x = iter, y = aad)) + geom_line() + labs(x = &quot;Number of Iteration&quot;, y = &quot;Average Absolute Discrepancy&quot;, title = &quot;True Probability Matrix ~ AAD&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(true.aad.plot, file = &quot;true.aad.plot.rds&quot;) # save the plot as a rds object # Calculating Maximum Absolute Discrepancy rm(list = ls()) # remove unnecessary objects voro &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/Voronoi both/Voronoi.estimates.rds&quot;) # getting the true pop vector from another object pop = voro$pop rm(voro) # Part One true1 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part1_400_new.rds&quot;) # read in the data true1 = cbind(true1,pop) # combining the data frame with the population vector mad1 = true1 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad1) = 0:400 # change column names rm(true1) # remove unused object # Part Two true2 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part401_800_new.rds&quot;) # read in the data true2 = cbind(true2,pop) # combining the data frame with the population vector mad2 = true2 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad2) = 401:801 # change column names rm(true2) # remove unused object # Part Three true3 &lt;- readRDS(&quot;~/OneDrive - Vysoká škola ekonomická v Praze/YAY/Estimates/P.oracle/u.est.non.inf.P.oracle.part801_1000_new.rds&quot;) # read in the data true3 = cbind(true3,pop) # combining the data frame with the population vector mad3 = true3 %&gt;% transmute_at(vars(contains(&quot;u&quot;)),funs(&quot;diff&quot; = abs(pop - .))) %&gt;% # transforming the columns summarise_all(funs(&quot;i&quot; = sum(.))) # summing up all rows for each column colnames(mad3) = 802:1002 # change column names rm(true3) # remove unused object mad = cbind(mad1,mad2,mad3) # combining all three parts together in one data frame madt = mad %&gt;% pivot_longer(-c(),names_to = &quot;iter&quot;, values_to = &quot;mad&quot;) # Transform the data frame into long form madt$iter = as.numeric(madt$iter) # cast the `iter` variable into numeric # plot using ggplot true.mad.plot = madt %&gt;% ggplot(aes(x = iter, y = mad)) + geom_line() + labs(x = &quot;Number of Iteration&quot;, y = &quot;Maximum Absolute Discrepancy&quot;, title = &quot;True Probability Matrix ~ MAD&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(true.mad.plot, file = &quot;true.mad.plot.rds&quot;) # save the plot as a rds object rm(list = ls()) # remove For the true population matrix, the discrepancy values stabilizes as the number of iterations increases. More specifically, starting at the 300th iteration, the discrepancy values are largely the same. "],["convergence-behavior-1.html", "8.2 Convergence Behavior", " 8.2 Convergence Behavior In this part, we will look at the convergence behavior over time through the actual numbers of estimated population and the residual. The residual is calculated as the true population minus the estimated population. The residual plot only contain certain number of iterations. esample &lt;- readRDS(&quot;~/Desktop/Eurostat/est.equal.1000iter.sample.rds&quot;) # Load in the data esample$internal.id = as.factor(esample$internal.id) # recast the `internal id` as a factor esample = esample %&gt;% select(-c(u.true.y)) # take out u.true.y esample = esample %&gt;% select(-c(pop.area.kind.helper,u.true)) # take out other columns length(colnames(esample)[406:1007]) # checking the length of the column names # Generate the column names through the use of for loops # It&#39;s important to put 0 in front or else ggplot will then graph 1000 in front of 100, for example. iters = c() for (x in 0:9) { iters = c(iters, paste(&quot;000&quot;,x,sep = &quot;&quot;)) } for (x in 10:99) { iters = c(iters, paste(&quot;00&quot;,x,sep = &quot;&quot;)) } for (x in 100:400) { iters = c(iters, paste(&quot;0&quot;,x,sep = &quot;&quot;)) } colnames(esample)[2:402] = iters iters2 = c() for (x in 401:999) { iters2 = c(iters2, paste(&quot;0&quot;,x,sep = &quot;&quot;)) } for (x in 1000:1002){ iters2 = c(iters2, paste(&quot;&quot;,x,sep = &quot;&quot;)) } colnames(esample)[406:1007] = iters2 equal = esample %&gt;% # transform the data frame into long form select(-c(pop)) %&gt;% pivot_longer(-c(internal.id, pop.area.kind,u.true.x), names_to = &quot;iter&quot;, values_to = &quot;sim&quot;) equal$iter = as.numeric(equal$iter) # cast the `iter` variable as a numeric variable # Plot of Estimated Population over Iterations equal.plot = equal %&gt;% ggplot(aes(x = iter, y = sim, group = internal.id)) + geom_line(aes(color = pop.area.kind)) + labs(x = &quot;Number of Iteration&quot;, y = &quot;Estimated Population&quot;, title = &quot;Equal Probability Matrix&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_color_ptol(breaks = c(&quot;Rural&quot;, &quot;Suburban&quot;, &quot;Urban&quot;)) + facet_grid(vars(pop.area.kind),scales=&quot;free&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(equal.plot, file = &quot;equal.plot.rds&quot;) # save the plot as RDS # Residual Plot esample &lt;- readRDS(&quot;~/Desktop/Eurostat/est.equal.1000iter.sample.rds&quot;) # read in the data esample = esample %&gt;% select(-c(u.true.y,pop.area.kind.helper)) # take out unused columns # Generate column names through the use of for loops niters = c() for (x in 0:9) { niters = c(niters, paste(&quot;u000&quot;,x,sep = &quot;&quot;)) } for (x in 10:99) { niters = c(niters, paste(&quot;u00&quot;,x,sep = &quot;&quot;)) } for (x in 100:400) { niters = c(niters, paste(&quot;u0&quot;,x,sep = &quot;&quot;)) } colnames(esample)[2:402] = niters niters2 = c() for (x in 401:999) { niters2 = c(niters2, paste(&quot;u0&quot;,x,sep = &quot;&quot;)) } for (x in 1000:1002){ niters2 = c(niters2, paste(&quot;u&quot;,x,sep = &quot;&quot;)) } colnames(esample)[406:1007] = niters2 # Calculate the residuals and transform the data frame into the long format. equalr = esample %&gt;% mutate(r0001 = u.true - u0001, r0002 = u.true - u0002, r0005 = u.true - u0005, r0010 = u.true - u0010, r0020 = u.true - u0020, r0050 = u.true - u0050, r0100 = u.true - u0100, r0200 = u.true - u0200, r0300 = u.true - u0300, r0400 = u.true - u0400, r0500 = u.true - u0500, r0600 = u.true - u0600, r0700 = u.true - u0700, r0800 = u.true - u0800, r0900 = u.true - u0900, r1000 = u.true - u1000 ) %&gt;% select(pop.area.kind,internal.id,r0001,r0002,r0005,r0010,r0020,r0050,r0100,r0200,r0300,r0400,r0500,r0600,r0700,r0800,r0900,r1000) %&gt;% pivot_longer(-c(internal.id, pop.area.kind), names_to = &quot;iter&quot;, values_to = &quot;resid&quot;) # Plot using ggplot equal.resid.plot = equalr %&gt;% ggplot(aes(x = iter, y = resid, group = internal.id)) + geom_line(aes(color = pop.area.kind)) + labs(x = &quot;Number of Iteration&quot;, y = &quot;Residual = Actual - Predicted&quot;, title = &quot;Equal Probability Matrix ~ Residual&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_color_ptol(breaks = c(&quot;Rural&quot;, &quot;Suburban&quot;, &quot;Urban&quot;)) + facet_grid(vars(pop.area.kind),scales = &quot;free&quot;) saveRDS(equal.resid.plot, file = &quot;equal.resid.plot.rds&quot;) # save the plot as ggplot. (#fig:distributionl eval 1)The left and right plots show a stratified sample (strata: area kind) and the tile specific estimatands’ convergence behaviour. The convergence behaviour differs between area kinds. The right plot emphasizes that the true value is not necessarily reached. The graphs above shows how the estimated population evolve over time (left) as well as its prediction error (right). From the graph on the left, most of the estimated population stabilizes rather quickly in rural and suburban tiles. With the urban tiles, it is harder to say exactly when the convergence will occur, especially there are a bit of variation. The residual plot (right) shows the error of prediction in comparison to the actual population in that specific tile. The rural tiles shows a trend of constant error of prediction over iterations. The suburban tiles generally shows the same trend as well, but also shows that there are tiles that overestimated. The urban tiles tend to have an underestimation. tsample &lt;- readRDS(&quot;~/Desktop/Eurostat/est.true.1000iter.sample.rds&quot;) # read in data tsample$internal.id = as.factor(tsample$internal.id) # cast the `internal id` variable as a factor colnames(tsample) colnames(tsample)[2:402] = iters # reuse the column names generated above colnames(tsample)[405:1006] = iters2 tequal = tsample %&gt;% # transform the data frame into long form pivot_longer(-c(internal.id, pop.area.kind,pop), names_to = &quot;iter&quot;, values_to = &quot;sim&quot;) tequal$iter = as.numeric(tequal$iter) # cast the `iter` variable as a numeric variable # Estimated Population over Iterations plot using ggplot true.plot = ggplot(data = tequal, aes(x = iter, y = sim, group = internal.id)) + geom_line(aes(color = pop.area.kind)) + labs(x = &quot;Number of Iteration&quot;, y = &quot;Estimated Population&quot;, title = &quot;True Population Matrix&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_color_ptol(breaks = c(&quot;Rural&quot;, &quot;Suburban&quot;, &quot;Urban&quot;)) + facet_grid(vars(pop.area.kind), scales = &quot;free&quot;) + scale_x_continuous(breaks=seq(0, 1000, 50)) saveRDS(true.plot, file = &quot;true.plot.rds&quot;) # save the plot as rds # Residual Plot colnames(tsample)[2:402] = niters # reused column names from above colnames(tsample)[405:1006] = niters2 # Calculate the residuals and transform the data frame into the long format. tequalr = tsample %&gt;% mutate(r001 = pop - u0001, r002 = pop - u0002, r005 = pop - u0005, r010 = pop - u0010, r020 = pop - u0020, r050 = pop - u0050, r100 = pop - u0100, r200 = pop - u0200, r300 = pop - u0300, r400 = pop - u0400, r500 = pop - u0500, r600 = pop - u0600, r700 = pop - u0700, r800 = pop - u0800, r900 = pop - u0900, r1000 = pop - u1000 ) %&gt;% select(pop.area.kind,internal.id,r001,r002,r005,r010,r020,r050,r100,r200,r300,r400,r500,r600,r700,r800) %&gt;% pivot_longer(-c(internal.id, pop.area.kind), names_to = &quot;iter&quot;, values_to = &quot;resid&quot;) # Plot using ggplot true.resid.plot = ggplot(data = tequalr, aes(x = iter, y = resid, group = internal.id)) + geom_line(aes(color = pop.area.kind)) + labs(x = &quot;Number of Iteration&quot;, y = &quot;Residual = Actual - Predicted&quot;, title = &quot;True Population Matrix ~ Residual&quot;) + theme(axis.text.x = element_text(angle = 90),legend.position = &quot;bottom&quot;) + scale_color_ptol(breaks = c(&quot;Rural&quot;, &quot;Suburban&quot;, &quot;Urban&quot;)) + facet_grid(vars(pop.area.kind),scales = &quot;free&quot;) saveRDS(true.resid.plot, file = &quot;true.resid.plot.rds&quot;) # save ggplot as rds format (#fig:distributionl eval 2)The left and right plots show a stratified sample (strata: area kind) and the tile specific estimatands’ convergence behaviour (equal probability P.matrix). The convergence behaviour differs between area kinds. The right plot emphasizes that the true value is not necessarily reached. Using the true population matrix, the estimated population stabilizes faster over time in comparison to the equal population matrix. However, there are a few tiles that do not stabilize as fast as we hoped. This is particularly evident in the urban tiles. The residual plot (right) shows the error of prediction over time by the type of tile. There seems to be a trend of increasing prediction error as the degree of urbanization increases as well. We can see that the range of error for suburban tiles range from 30 to -10 and the range of error for urban tiles are between 100 and -75. The suburban tiles seems to underestimate and the urban tiles seems to overestimate. "]]
>>>>>>> 9beab66830f52f6e759d00f01df252bd8d77f9ad
