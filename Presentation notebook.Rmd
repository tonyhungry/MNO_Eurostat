---
title: "Estimating present population based on Mobile Network Operator data - a simulation study"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Stefania, Giulia, Tony, Marco"
date: "`r Sys.Date()`"
output:  
  bookdown::html_document2:
    code_download: true
    theme: lumen 
    toc: true  
    toc_float: true
    number_sections: true
    fig_caption: yes
---

```{r packages, message=FALSE}
library(tidyverse)
library(sf)
library(raster)
library(Matrix)
library(knitr)
library(kableExtra)
library(ggthemes)
library(cowplot)
library(ggpubr)

set.seed(762)
```

Mobile phones are an essential part of modern life. From going on Twitter to complain about politics to texting with friends about the latest and hottest gossip and live streaming on Facebook about an underground party to sharing immediate information in the front of the battle lines. Mobile phones have revolutionized the way we communicate with each other and how we lead our daily lives. From the point of view in Official Statistics, mobile phones present an opportunity like no other: a fast and immediate calculation of present population. Present population "is composed by all individuals who are physically present in the geographic area of interest at a selected reference time" [1]. In this study, we will evaluate and compare different estimation techniques to infer the present population in a specific region. We will particularly focus on the quality of the estimation when simulating hotspots (high population density) in low signal density areas. This is the case for example on holidays where people go on vacation in less urbanized areas.

This exercise will be a simulation study partly based on real and simulated data from either official sources or from our own calculations. The notebook relies on multiple scripts that follow a methodological/technical chain. Each chain element can be considered as an independent module which makes it easy to change parameters in a module and follow through with the remaining chain. Therefore, multiple objects are created in advance (in an efficient manner because of parallelization) and loaded into the notebook. The objects will be explained, their parameters presented and the source code hyperlinked in this notebook.

Currently three modules are implemented:

-   Generating a population based on real census data and spatial demographic clustering

-   Generating a radio cell network with multiple parameters

-   Creating the device-to-cell association

# Generating a semi-synthetic population based on real census data

We have retrieved population census data from the German Federal Statistical Office on Germany [2] (<https://www.destatis.de/EN/Home/_node.html>). This data entails population count categories on the 100m\*100m tile level. For computational reasons, this version will only focus on a subset of the tiles located in the state of Bavaria, which is situated in the south-east of Germany. We chose this area because it comprises both urban, suburban, and rural areas. The underlying code is written in a modular way in order to have the possibility to repurpose our models for other regions. Furthermore, once a high computing machine is available, we could easily scale this notebook to the entirety of Germany.

The sample population value is used as the number of mobile phones in a specific tile and throughout in this current version of the notebook. This sample population is a direct reference to the u vector in the working paper. In subsequent versions, this original population value could be adjusted based on additional variables to get a more realistic count of people with mobile phones in each tile.

The link to the source code for the census.de.100.m.tile object is [here](https://github.com/R-ramljak/MNO_GM/blob/master/1_Read%20in%20data.R).

```{r exploration census, message=FALSE}
census.de.100m.tile <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/census.tile.final.rds") 
 
dim(census.de.100m.tile)

class(census.de.100m.tile) 


census.de.100m.tile %>% 
  st_drop_geometry() %>%  
  sample_n(10) %>%  
  # head() %>% 
  kbl(caption = "Exploration of the dataset about tiles of South Bavaria") %>% 
  kable_minimal() 
```

\#\#Exploration of the dataset about tiles of South Bavaria

Important features and parameters:

-   Our focus areas entails `r dim(census.de.100m.tile)[1]` tiles on a regular grid (South Bavaria)

-   We have a continuous and a `r dim(census.de.100m.tile)[2]` level ordinal variable representing the population density for each tile

In the following section we then proceed to classify the tiles based on the number of populations per tile as well its proximity to neighboring tiles in order identify groups of tiles into different categories of urbanization. In this section we will be using the `cca` function from the `OSC` package. After the classification, we then proceed to look at the overall distribution of the tiles based on the categories of urbanization.

```{r focus area}
# # Bounding box of focus area
bb.focus.dat <- data.frame(xmin = 4400000, xmax = 4500000,
                           ymin = 2700000, ymax = 2900000)
bb.focus.vec <- c(xmin = 4400000, xmax = 4500000,
                  ymin = 2700000, ymax = 2900000)

#Download data from : https://gadm.org/download_country_v3.html --> R(sf) level 1

germany.raw <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/gadm36_DEU_1_sf.rds") 
germany <- germany.raw %>%  
  st_transform(crs = 3035)

focus.area.plot <- germany %>%  
  ggplot() + 
  geom_sf() + 
  geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
                                      xmin = xmin, xmax = xmax,  
                                     color = "red"),  
            size = 1, fill = "transparent") + 
  ggtitle("") + 
  scale_color_identity(name = "", 
                          # breaks = c("Focus area"), 
                          labels = c("Focus area"), 
                          guide = "legend") +
  labs(x = NULL, y = NULL,
    title = "Fig.1: Focusing on a part of South Bavaria",
    subtitle = "We will only focus on a subset of the tiles located in the state of 
Bavaria because it comprises both urban, suburban, and rural areas")
 
plot_grid(focus.area.plot, hjust = -0.1, label_size = 12)
```

```{r pop distribution 1}
# Since there is a large percentage of zeros in the tiles, we added 1 to every tile to receive valid values for the log transformation

# ECCDF of population distribution 
ECCDF.pop.data <- census.de.100m.tile %>% 
  sample_n(1000) %>%
  mutate(pop.plot = pop + 1) %>%  
  arrange(pop.plot) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>%  
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.pop = log10(pop.plot)) %>%  
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(pop.area.kind = case_when(pop == 0 ~ "Uninhabitated", 
                                   TRUE ~ pop.area.kind))

prop.class <- data.frame( 
  class = c("Rural","Suburban", "Uninhabitated","Urban"), 
  n = summary(as.factor(ECCDF.pop.data$pop.area.kind)), 
  prop = round(summary(as.factor(ECCDF.pop.data$pop.area.kind)) / length(census.de.100m.tile$internal.id), digits = 4) * 100)  %>% 
  mutate(class = factor(class)) %>% 
  arrange(desc(class)) %>% 
  mutate(lab.ypos = cumsum(prop) - 0.5 * prop) 
 
tile.prop.plot <- prop.class %>% 
  ggplot(aes(x = "", y = prop, fill = class)) + 
  geom_bar(width = 1, stat = "identity", color = "white") + 
  scale_fill_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) +
  geom_text(aes(y = lab.ypos, label = paste0(prop, "%")), color = "black") +
  theme(legend.position = "bottom") +
  labs(x = "Class", y = "Number of tiles",
    title = "Fig.2.1 Tile proportion",
    subtitle = "The classification results from the clustering algorithm and the proportion of people in the area categories") + 
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))

result.sf <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/result.sf.rds") 
 
cluster.plot <- result.sf %>%  
  ggplot() +  
  geom_sf(aes(col = factor(area.kind)), show.legend = F) + 
  ggtitle("", subtitle = "Clustering Results") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) +  
  scale_color_ptol(breaks = c("Uninhabited", "Rural", "Suburban", "Urban")) +
   labs(title= "Figure 2.2: Clustering results",
    subtitle = "Distribution of the four different categories of tiles;
    obtained through spatial clustering") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5))

plot_grid(cluster.plot, tile.prop.plot, labels = "Fig.2: Population Classification",  
            hjust = -0.1, label_size = 12, rel_widths = c(0.8, 1)) 
```


Note: We understand that the threshold used in this section is not optimal yet, however, optimization of the parameters is out of the scope of this project.

Figure 2 shows the classification results from the clustering algorithm and the proportion of people in the area categories. We aimed at having 4 different categories: Uninhabited, Rural, Suburban and Urban. When working on this very low spatial resolution, one cannot just classify tiles independently based on their respective continuous population value but ones needs to take spatial dependence into consideration in order to classify urban centers. Therefore, we apply a spatial clustering method, mainly for identifying the last two categories. In order to run the clustering algorithm, the original census population is first divided into tiles above and below 70 people per tile. Tiles below 70 are either classified as Uninhabited or Rural, from the start on (Uninhabited corresponds to the tiles with 0 population). The clustering is then done on the tiles that are above 70 people per tile. Based on the results of the clustering, we define urban areas as clusters that have an agglomeration of more than 100 tiles. Suburban areas are defined as clusters that have more than 50 and less than or equal to 100 tiles. The remaining clusters are considered as Rural areas and therefore result in the same classification as the tiles from above, which had less than 70 people.

The stacked bar plot shows the proportions of the tiles according to the four categories. Based on our clustering algorithm, `r prop.class$prop[1]`% of the tiles are urban areas. `r prop.class$prop[2]`% of the tiles are uninhabited areas. `r prop.class$prop[3]`% of the tiles are suburban areas, and `r prop.class$prop[4]`% of the tiles are rural areas.

```{r pop distribution 2}
pop.dist.map.plot <- ECCDF.pop.data %>% 
  # sample_n(10000) %>% 
  ggplot() + 
  geom_sf(aes(color = pop.area.kind), show.legend = F) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = "Geographic distribution") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) 
 
ECCDF.pop.plot <- ECCDF.pop.data %>%   
  # sample_n(1000) %>% 
  ggplot() + 
  geom_point(aes(x = log10.pop, y = log10.cum.prob.comp, 
                 color = pop.area.kind)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 1.5, y = -0.2, label = "50% of the data") + 
  geom_text(x = 1.5, y = -0.9, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban")) + 
  ggtitle("", subtitle = "Empirical cumulative complementary\ndistribution function") +  
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)",  
        colour = "") + 
  ylim(-7, 0) +
  theme(legend.position = "bottom") 
 

ECDF.pop.plot <- ECCDF.pop.data %>%   
  # sample_n(1000) %>% 
  ggplot() + 
  geom_point(aes(x = pop.plot, y = cum.prob.comp, color = pop.area.kind)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  labs(y = "", x = "") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

pop.dist.ecdf.insert <- ECCDF.pop.plot +
  annotation_custom(ggplotGrob(ECDF.pop.plot), 
                    xmin = 0, xmax = 1.5, 
                    ymin = -7, ymax = -3)

plot_grid(pop.dist.map.plot, pop.dist.ecdf.insert, labels = "Mobile phone density per tile",  
          hjust = -0.1, label_size = 12, rel_widths = c(0.8, 1))
```


Figure 3 shows the mobile phone density per tile in the focus area. In particular, we have 4 different colors representing the clusters: Uninhabited, Rural, Suburban and Urban.

However, to have a deeper look of the mobile phone density per tile, in the figure (write the figure number of the first ECCDF) we choose to represent data with an empirical cumulative complementary distribution function [using a log base 10 transformation].

The ECCDF is a step function with jumps `i/n` at observation values, where `i` is the number of tied observations at that value. Moreover, missing values are ignored and the objective "complementary" means that we need to subtract 1 - the cumulative probability. It is commonly used with variables that a have highly skewed distribution ??? as expected the population variable on this low spatial resolution at hand is heavily right skewed.

As the figure suggests, 50% of the data are represented by uninhabited tiles with no phones; furthermore, 90% of the tiles contain less than half of the mobile phones in our focus area. One can also see the tiles' classification based on the clustering results. Some tiles classified as Rural have higher values for their mobile phone population - this is because they are not considered as an Urban or Suburban cluster, as mentioned above. 10% left are tiles both urban and rural containing 0.5 and above mobile phones.

# Generation of a synthetic the Radio Network

We generate a radio network, which is composed of three layers. The layers follow the pop.area.kind variable - layer 1 (Rural) spans over the rural, suburban and urban tiles, layer 2 (Suburban) spans over the suburban and urban tiles and layer 3 (Urban) is spanned over the urban tiles.

**Important features and parameters of the generated radio network are:**

-   The layers follow a hexagon shape with cell towers located in the respective centroid of each hexagon

-   Towers vary in distance to each other of the same layer, i.e. how far/close are towers of the same layer located to each other: layer 1 = 27,000m; layer 2 = 7000m; layer 3 = 900m (-\> the more urbanized, the closer the towers are too each other -\> denser coverage). Furthermore, hexagon independent rotation in terms of the first layer is executed: layer 2 = 35 degrees; layer 3 = 70 degrees

-   Each cell tower location is jittered in order to break the symmetry. The jitter amount depends on the layer: layer 1 = 5000m, layer 2 = 1000m, layer 3 = 400m.

-   Each tower contains three antennas pointing into 120 degree differing directions.

-   The layer determines the coverage diameter of an antenna: layer 1 = 15,000m; layer 2 = 2500m; layer 3 = 500m

-   Each tile of the focus area is sufficiently covered by at least one antenna and the antennas' coverage areas are allowed to overlap.

-   Parameters concerning the device to cell association are specified in the next section

The link to the source code for the layers.1 object as well as the coverage.areas.1 object is [here](https://github.com/R-ramljak/MNO_GM/blob/master/2_Radio%20cell%20generation.R).

The link to the source code for the layers object as well as the coverage.areas object is [here] (<https://github.com/R-ramljak/MNO_Eurostat/blob/master/code/2_Radio%20cell%20generation.R>).

```{r network layers}
layers <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/radio cell layers.rds") 
coverage.areas <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/coverage.areas.rds") 
 
coverage.layer1 <- coverage.areas %>%  
  filter(area.kind == "Rural") %>%  
  st_drop_geometry() %>%  
  dplyr::select(-antenna.centroid) %>%  
  st_as_sf(coords = c("X.tow", "Y.tow"), crs = 3035) 
 
layers.plot <- layers[[1]] %>% 
  st_as_sf(crs = 3035) %>%  
  ggplot() + 
    # geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,  
    #                                   xmin = xmin, xmax = xmax),  
    #         color = "black", size = 0.3, alpha = 0.5, fill = alpha("grey", 0)) + 
  geom_sf(linetype = "dotted") + 
  geom_sf(data = coverage.layer1, aes(color = "#4273C5"), shape = 17) + 
  scale_color_identity(name = "", 
                       # breaks = c("Focus area"), 
                       labels = c("Jittered tower location"), 
                       guide = "legend") + 
  labs(x = NULL, y = NULL,
    subtitle = "Towers are located in the centroid of a hexagon.") +
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
  plot.subtitle = element_text(size=9,hjust = 0.5))
   
plot_grid(layers.plot, labels = "Fig.4: Radio network - Example Layer 1 (Rural)",  
          hjust = -0.1, label_size = 12)
```

We use a hexagonal structure to place towers across our focus area. This is a quite realistic setup for cell towers. Each hexagon corresponds to one tower which is originally placed in the centroid of the respective hexagon. In order to exclude symmetrical structure, we implement some randomness in the exact location of the cell towers. Figure 3 exemplifies the effect of the jitter parameter in the 1st layer - the actual location deviates slightly from the centroid in order to break the symmetry of the underlying hexagonal structure. This is done for every layer.

The setup of a tower with its corresponding antennas is in every layer the same: Three antennas per tower, pointing into 120 degree differing directions. The animated visualization exemplifies this for any generic tower.

```{r animation}
knitr::include_graphics("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/antenna animation.gif")
```

Basically, a tower is generated at its specified location, then three antennas are created. For the operationalized data structure, the antenna location is not really relevant as it corresponds to the respective tower location. What is more important are the antennas' *coverage area centroids* because they describe the middle point of the then generated circular coverage area. The specific radius of any generic coverage area is layer specific and listed above. As indicated in the animation, an antenna specific coverage area is setup with a variable *coverage intensity profile*. Basically, cell phones that are closer to the coverage area centroid of any antenna, have a higher coverage probability, which will be later introduced as the *signal strength* parameter.

The following table presents the number of towers and the number of antennas of each layer. The number of antennas is not always a perfect factor of 3 as the coverage areas are cropped according to the focus area. This means if the complete coverage area of an antenna lies outside of the focus area it is discarded.

```{r coverage areas 1}
tile.count <- census.de.100m.tile %>%  
  mutate(area.kind = case_when(pop.area.kind %in% c("Rural", "Suburban", "Urban") ~ "Rural", 
                               pop.area.kind %in% c("Suburban", "Urban") ~ "Suburban", 
                               pop.area.kind %in% c("Urban") ~ "Urban")) %>%  
  group_by(area.kind) %>%  
  summarise(area.in.sq.km = n() / 100) 

coverage.areas %>%  
  st_drop_geometry() %>%  
  group_by(area.kind, tower.ID) %>%  
  summarise(n.antenna = n(), .groups = "drop") %>%  
  ungroup() %>%  
  group_by(area.kind) %>%  
  summarise(n.tower = n(), 
            n.antenna = sum(n.antenna), .groups = "drop") %>%  
  left_join(tile.count, by = "area.kind") %>%  
  dplyr::select(layer = area.kind, n.tower, n.antenna, area.in.sq.km) %>%  
  kbl(caption = "Number of towers and antennas per layer") %>% 
  kable_minimal() 
```

As described in the parameter list above, rural areas are covered only by layer 1, suburban areas are covered by layer 1 and 2 and the urbanized areas are covered by all three layers. The distances between towers of the same layer decrease in layer 2 and layer 3 compared to layer 1. This leads to denser networks within these layers represented by the higher numbers of towers and therefore higher numbers of antennas in layer 2 and 3, given their area. The reason for this is that any generic antenna can only offer signal service to a limited amount of number of mobile phones. To cover all cell phones in more urbanized areas a denser radio cell network is needed in these areas. This feature will be later introduced as the *capacity* parameter.

The following figures present the actual coverage of each layer for the focus area.

```{r coverage areas 2}
coverage.area.plot <- coverage.areas %>%  
  ggplot() + 
  geom_sf(aes(col = area.kind), fill = NA) + 
  facet_grid(cols = vars(area.kind)) + 
  ggtitle("", subtitle = "Signal density increases with increasing population density") + 
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  labs(x = NULL, y = NULL,
    subtitle ="The circles represents the coverage area of each tower per layer depending on the signal strengh. The signal density increases with increasing population density") +
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
  plot.subtitle = element_text(size=9,hjust = 0.5))

plot_grid(coverage.area.plot, labels = "Coverage per layer",  
          hjust = -0.1, label_size = 12) 
```

The interpretations of the table above correspond to the level of coverage of each layer. It should be noticed that the antennas' coverage areas are allowed to overlap - with antennas of the same tower, as well as across towers of the same or another layer.

```{r coverage areas 3}
# Implement shape of focus area
coverage.area.full.plot <- coverage.areas %>% 
  ggplot() +
  geom_sf(aes(col = area.kind), fill = NA) +
  ggtitle("", subtitle = "Full coverage") +
    # geom_rect(data = bb.focus.dat, aes(ymin = ymin, ymax = ymax,
    #                                   xmin = xmin, xmax = xmax),
    #         color = "black", size = 0.3, alpha = 0.5, fill = alpha("grey", 0)) +
    scale_color_ptol(breaks = c("Rural", "Suburban", "Urban"), "Layer") +
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
  plot.subtitle = element_text(size=9,hjust = 0.5))

plot_grid(pop.dist.map.plot, coverage.area.full.plot, labels = "Full coverage corresponding to the density", 
          hjust = -0.1, label_size = 12)
```

Figure 6 presents the full network structure. By comparing the network structure to the tile density one can see that full, partially overlapping coverage is granted for all areas and that the network layering structure follows suit with the true geographical population density.

```{r coverage intensity}
# dev.to.cell.classified <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/dev.to.cell.classified.final.rds")
# coverage.intensity <- dev.to.cell.classified %>% 
#   filter(!weight.pij == 0) %>% 
#   group_by(internal.id) %>% 
#   summarise(n.cells.cover = n()) %>% 
#   arrange(n.cells.cover) %>% 
#   mutate(prob = 1 / n()) %>% 
#   mutate(cum.prob = cumsum(prob))
# 
# Fig.7 <- coverage.intensity %>%  
#   ggplot() + 
#   stat_count(aes(n.cells.cover), fill = "#4477A9") +
#   scale_x_continuous(breaks = c(1:11)) +
#   # geom_vline(yintercept = -0.3010300, linetype = "dotted") + implement half line
#   labs(y = "Count of tiles", x = "Covered by ... antennas", 
#        colour = "") +
#   theme(legend.position = "bottom")
# plot_grid(Fig.6, labels = "Fig.4: Number of antennas covering a tile", 
#           hjust = -0.1, label_size = 12)
```

(STILL UNDER CONSTRUCTION Figure 7 shows a histogram representing the number of antennas per tile. The distribution is right skewed with a mean of 2 antennas per tile, a minimum of 1 antenna per tile a maximum of 11. It is definitively possible to claim that even if we are working with synthetic data, they are realistic values. Moreover, if a tile is covered by e.g. 3 antennas that all of these antennas are sufficiently covering the tile, this means that they have a non-zero probability $pij$.)

# Device-to-cell association

At this stage we have added to the geographically distributed mobile phone population a radio network, which is setup in three layers, spanning respectively across tiles that correspond to specific tile classification. (`pop.area.kind`).

The following module will establish the association between mobile phones of a generic tile to a relevant antenna. The result will be a reference matrix $P$ of size $I x J$, where I denotes the total number of radio cells (antennas), $J$ is the total number of tiles and the elements correspond to the probability of the mobile phones of any tile $j$ are registered in the cell $i$. With $P$ one is able to simulate the column vector $c$ (random variable) which describes the total count of mobile phone associated to a radio cell.

Assuming that $\mathcal{L}_{j}$ denotes the subset of radio cells covering a particular tile (remember, overlapping coverage areas are very common). This means that these respective radio cells are competing with each other to be associated with the cell phones in the tile. We therefore assign probabilities which describe the respective association between a radio cell $i$ and tile $j$. This probability depends on the parameter signal strength which we mimic with a simple linear function that describes the gradual decrease in signal the further away the tile centroid $j$ is from the coverage area centroid of $i$:

$$
s_{ij} = \frac{d_{ij}}{r_{i}}
$$

We basically calculate the distance between the two centroids, $d_{ij}$, and divide it between the radius of that radio cell, $r_{i}$- it is denoted by $s_{ij}$. We introduce a minimum threshold value $\nu$ which limits radio cells with a too low signal intensity $s_{ij}$ for a particular tile to be able to be picked up by a mobile phone in that tile - resulting in the minimum value of 0. We also introduce a maximum threshold, describing tiles that are very close to the coverage area centroid, i.e. a high value for $s_{ij}$ -- when passing this threshold their respective $s_{ij}$ values result in the maximum value 1. This particular operationalization of a function modeling the signal strength parameter instead of fixed categorical signal strength values makes the overall workflow of the notebook more realistic (granularity) and more modular as one can later implement very easy even more realistic functions describing the signal strength parameter. In this scenario we have implemented a minimum threshold of $\nu = 0.01$ and a maximum threshold of $\zeta = 0.01$ depending on $r_{i}$. The exact operationalization can be found [here](https://github.com/R-ramljak/MNO_GM/blob/master/3_device%20to%20cell.R).

The elements of $P$ - the probability with which the mobile phones within a particular cell are associated with a particular radio cell - are defined by

$$
p_{ij} = \frac{s_{ij}}{\sum_{i \in \mathcal{L}_{j}} s_{ij}}
$$

where $s_{ij}$ describes the signal intensity of a particular cell $i$ associated with a particular tile $j$, and $\mathcal{L}_{j}$ describes the subset of radio cells that are covering the tile $j$. We then simulate the tile specific experiments - every mobile phone within a tile will be independently assigned to relevant radio cell with the probability $p_{ij}$. The result is the column vector $c$ which will act as a reference for the later on introduced estimation strategies.

```{r }
C.vec.df <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/C.vec.df.final.rds")

# ECCDF of population distribution 
ECCDF.phones.data <- C.vec.df %>% 
  mutate(layer = case_when(str_detect(antenna.ID, "RT") ~ "Layer 1",
                           str_detect(antenna.ID, "ST") ~ "Layer 2",
                           str_detect(antenna.ID, "UT") ~ "Layer 3")) %>% 
  arrange(phones.sum) %>%  
  mutate(prob = 1 / n()) %>%  
  mutate(cum.prob = cumsum(prob)) %>% 
  mutate(cum.prob.comp = 1 - cum.prob) %>% 
  mutate(log10.cum.prob.comp = log10(1 - cum.prob)) %>%  
  mutate(log10.phones = log10(phones.sum))

ECCDF.phones.plot <- ECCDF.phones.data %>%   
  ggplot() + 
  geom_point(aes(x = log10.phones, y = log10.cum.prob.comp, 
                 color = layer)) + 
  geom_hline(yintercept = -0.3010300, linetype = "dotted") + 
  geom_hline(yintercept = -1, linetype = "dotted") + 
  geom_text(x = 4, y = -0.15, label = "50% of the data") + 
  geom_text(x = 4, y = -0.85, label = "90% of the data") + 
  scale_color_ptol(breaks = c("Layer 1", "Layer 2", "Layer 3")) + 
  ggtitle("") +
  labs(y = "log10(Prob(Y > x))", x = "log10(Mobile phones)", colour = "",
       subtitle ="In this figure there is rapresented the EECDF for the c vector. It is possible to claim that the 90% of the obseved number of mobile devices are associated to rural tiles/towers. ")+
  theme(plot.title = element_text(size=10, face="bold", hjust = 0.5),
        plot.subtitle = element_text(size=9,hjust = 0.5))

ECDF.phones.plot <- ECCDF.phones.data %>%   
  # sample_n(1000) %>% 
  ggplot() + 
  geom_point(aes(x = phones.sum, y = cum.prob.comp, color = layer)) + 
  scale_color_ptol(breaks = c("Uninhabitated", "Rural", "Suburban", "Urban"), guide = FALSE, expand = c(0, 0)) +
  labs(y = "", x = "") +
  theme(plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 9, hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

pop.dist.ecdf.insert <- ECCDF.phones.plot +
  annotation_custom(ggplotGrob(ECDF.phones.plot), 
                    xmin = 0, xmax = 2, 
                    ymin = -3.5, ymax = -1)
    

plot_grid(pop.dist.ecdf.insert, labels = "ECCDF c Vector",  hjust = -0.1, label_size = 12)
```

# Estimation strategies

-   Network module: Flat coverage: $p'_{ij} = \frac{1}{|\mathcal{L}_{j}|}$

Estimation strategies:

-   bayes rule: $\hat{u}_{j} = a_{j}\sum_{i = 1}^{I} c_{i} \frac{p_{ij}}{\sum_{k = 1}^{J} p_{ik} a_{k}}$

-   MLE Poisson: $\hat{u}^{m+1}_{j} = \hat{u}^{m}_{j}\sum_{i = 1}^{I} c_{i} \frac{p_{ij}}{\sum_{k = 1}^{J} p_{ik} \hat{u}^{m}_{k}}$

```{r}



estimations <- readRDS("C:/Users/Marco/OneDrive - Universiteit Utrecht/MNO/working objects/working objects/sampled.est.results.rds")
est.visual <- estimations %>% 
  dplyr::select(internal.id, P.equal2, P.equal10, P.true10, oracle, pop.area.kind, pop, geometry) %>% 
  st_as_sf() %>% 
  mutate_at(c("P.equal2", "P.equal10", "P.true10", "oracle"), ~case_when(. > 50 ~ 1,
                                                                         TRUE ~ 0))

```

# Evaluation

The first evaluation is executed through visual analysis based on the complete focus area. The first map shows the ground truth population. The following maps show the models in the following order and specification: Currently three modules are implemented:

-   

    (1) Simple Bayesian, non informative constant prior, equal probability P.matrix

-   

    (2) MLE Poisson, 10 iterations, non informative constant prior, equal P.matrix

-   

    (3) MLE Poisson, 10 iterations, non informative constant prior, true P.matrix

-   

    (3) Oracle, true pop prior, true P.matrix

```{r}
# comparison
Fig.9.SB <- est.visual %>% 
  ggplot() +
  geom_sf(aes(color = factor(P.equal2), show.legend = F)) +
  scale_color_manual(values = c("grey", "black"), 
                     labels = c("u hat > 50", "u <= 50")) +
  ggtitle("", subtitle = "(1) 1 iter, constant prior, equal P.matrix") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) 

Fig.9.equal <- est.visual %>% 
  ggplot() +
  geom_sf(aes(color = factor(P.equal10))) +
  scale_color_manual(values = c("grey", "black"), 
                     labels = c("u hat > 50", "u <= 50"),
                     name = "") +
  ggtitle("", subtitle = "(2) 10 iter, constant prior, equal P.matrix") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) 

Fig.9.true <- est.visual %>% 
  ggplot() +
  geom_sf(aes(color = factor(P.true10), show.legend = F)) +
  scale_color_manual(values = c("grey", "black"), 
                     labels = c("u hat > 50", "u <= 50")) +
  ggtitle("", subtitle = "(3) 10 iter, constant prior, true P.matrix") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) 

Fig.9.oracle <- est.visual %>% 
  ggplot() +
  geom_sf(aes(color = factor(oracle))) +
  scale_color_manual(values = c("grey", "black"), 
                     labels = c("u hat > 50", "u <= 50"),
                     name = "") +
  ggtitle("", subtitle = "(4) 10 iter, true prior, true P.matrix") + 
  theme(plot.margin = unit(c(0, 0, 0, 0), "mm")) 


plot_grid(Fig.3.1, labels = "True population",  
          hjust = -0.1, label_size = 12) 

```



# References

[1] Ricciato F, Lanzieri G., Wirthmann A., and Seynaeve G.(2020) Towards a methodological framework for estimating present population density from mobile network operator data. <https://ec.europa.eu/eurostat/cros/content/towards-methodological-framework-estimating-present-population-density-mobile-network-operator-data-extended-version_en>

[2]<https://gadm.org/download_country_v3.html>

[3]<https://www.destatis.de/EN/Home/_node.html>

[4]<https://tma.ifip.org/2016/phdSchool/data/toy_excercise_solution.pdf>
